#pragma once
#include <string>
#include <unordered_map>

class BinaryReader;
struct deserializer;

typedef void dsfunc_t(BinaryReader&, std::string&);
typedef std::unordered_map<uint64_t, deserializer> dspropmap_t;

struct deserializer {
	dsfunc_t* callback = nullptr;
	const char* name = nullptr;
	int arrayLength = 0; // If > 0, treat this as a static array

	void Exec(BinaryReader& reader, std::string& writeTo) const;
};

struct deserialTypeInfo {
	void(*callback)(BinaryReader& reader, std::string& writeTo) = nullptr;
	const char* name = nullptr;
};

struct entityclass_t {
	std::string filepath;
	uint64_t parent = 0;
	uint32_t typehash = 0;
	bool deserialized = false;
};

enum LogicType {
	LT_LogicClass,
	LT_LogicEntity,
	LT_LogicFX,
	LT_LogicLibrary,
	LT_LogicUIWidget,
	LT_MAXIMUM
};

enum class DeserialMode {
	entitydef,
	logic,
	mapentities
};

namespace deserial {

	/* Generated by reflection code */
	extern const std::unordered_map<uint32_t, deserialTypeInfo> typeInfoPtrMap;

	/* Populated before deserialization occurs */
	extern std::unordered_map<uint64_t, std::string> declHashMap; // More accurately described as a hashmap of all resource dependencies
	extern std::unordered_map<uint64_t, entityclass_t> entityclassmap;

	void SetDeserialMode(DeserialMode newmode);
	
	/* Debugging */
	void ds_debugging();
	int ds_debugWarningCount();

	/* Entry Points */
	void ds_start_entitydef(BinaryReader& reader, std::string& writeTo, uint64_t entityhash);
	void ds_start_mapentities(BinaryReader& reader, std::string& writeTo);
	void ds_start_logicdecl(BinaryReader& reader, std::string& writeTo, LogicType declclass);

	/* Pointers */
	dsfunc_t ds_pointerbase;
	dsfunc_t ds_pointerdeclinfo;
	dsfunc_t ds_pointerdecl;

	/* Polymorphic Types */
	dsfunc_t ds_idTypeInfoPtr;
	dsfunc_t ds_idTypeInfoObjectPtr;

	/* Containers */
	void ds_enumbase(BinaryReader& reader, std::string& writeTo, const std::unordered_map<uint64_t, const char*>& enumMap);
	void ds_structbase(BinaryReader& reader, std::string& writeTo, const dspropmap_t& propMap);
	void ds_idList(BinaryReader& reader, std::string& writeTo, dsfunc_t* callback);
	void ds_staticList(BinaryReader& reader, std::string& writeTo, deserializer basetype);
	void ds_idListMap(BinaryReader& reader, std::string& writeTo, dsfunc_t* keyfunc, dsfunc_t* valuefunc);
	
	/* Manually Implemented Structs */
	dsfunc_t ds_idStr;
	dsfunc_t ds_attachParent_t;
	dsfunc_t ds_idRenderModelWeakHandle;
	dsfunc_t ds_idLogicProperties;
	dsfunc_t ds_idEventArg;

	/* Primitive Types */
	dsfunc_t ds_bool;
	dsfunc_t ds_char;
	dsfunc_t ds_unsigned_char;
	dsfunc_t ds_wchar_t;
	dsfunc_t ds_short;
	dsfunc_t ds_unsigned_short;
	dsfunc_t ds_int;
	dsfunc_t ds_unsigned_int;
	dsfunc_t ds_long;
	dsfunc_t ds_long_long;
	dsfunc_t ds_unsigned_long;
	dsfunc_t ds_unsigned_long_long;
	dsfunc_t ds_float;
	dsfunc_t ds_double;

};

